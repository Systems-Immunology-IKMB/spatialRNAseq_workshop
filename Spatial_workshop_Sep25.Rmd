---
title: "Spatial RNAseq 101"
output: html_document
date: "2025-09-04"
---

# Welcome to KLS Summer School Workshop on Spatial RNA-seq

Spatial transcriptomics is a technique that measures gene expression in a tissue while preserving the spatial location of each measurement, allowing researchers to see where specific genes are active within the tissue.

In this workshop we will cover key steps in the analysis workflow, including quality control, preprocessing, clustering and visualization, cluster annotation, spatial clustering, and integration with single-cell transcriptomics data.

## 1. Setting up your R environment 

Before diving into the data, we need to load a few important R packages. These libraries will provide the tools we need for analysis and visualization.
```{r setup, include=FALSE}
#| label: setup
#| message: false

library(Seurat)     # Main package for single-cell and spatial transcriptomics analysis
library(patchwork)  # Helps combine multiple ggplot2 plots into one figure
library(tidyverse)  # Essential collection of R packages, including ggplot2, dplyr, magrittr
library(grid)    # Plot multiple objects
library(viridis) # A series of color maps that are designed to improve graph readability
library(SeuratWrappers) #SeuratWrappers is a collection of community-provided methods and extensions for Seurat.
library(spacexr) #learning cell types and cell type-specific differential expression in spatial transcriptomics data.
# For other plots

# Colors
cal_pal50 = c("#Fa1a8e", "#009B7D", "#ff9933", "#7083a4", "#ffce45", "#015e05", 
              "#fedf25", "#d2b48c", "#bb55e1", "#6ec5ab", "#5d57af", "#143341", 
              "#761445", "#d65b5a", "#94043a", "#e7a6cd", "#204519", "#87afd1", 
              "#9b9a9d", "#f95b70", "#83c874", "#808080", "#452b5b", "#ecb100", 
              "#f46124", "#525252", "#4c84a3", "#00bfff", "#01b4c6", "#174d79", 
              "#a6a0f2", "#76facc", "#8491be", "#a32a2f", "#1c8859", "#2cc012", 
              "#35782b", "#9c6755", "#3b3960", "#eeb0a1", "#3e1e13", "#0064c3", 
              "#d81e4a", "#74646c", "#f675da", "#ffce45", "#ec7014", "#e50000", 
              "#000000", "#a4527c", "#041859")

```

This code sets up your R session for a particular directory in your computer, where the datasets will be loaded from, and results will be saved in.
```{r}

setwd('/a/b/c/d/Spatial_SummerSchool/')
```

# Loading the dataset
Go to https://www.10xgenomics.com/datasets/visium-hd-cytassist-gene-expression-libraries-of-mouse-intestine and download the dataset: Intestine mice (swiss-roll) as batch.
In this session, we focus on the 8 µm bins and do not need load the 16 µm bins.

```{r cars}

sp = Load10X_Spatial("datasets/binned_outputs/square_008um/", assay="RNA")
sp$orig.ident = "Intestine"
Idents(sp) = "Intestine"
sp

```

## 2. Quality control

## Why quality control?

In spatial transcriptomics (and any sequencing-based assay), not all bins are equally informative. Quality Control (QC) is used to identify and remove low-quality bins from the dataset before further analysis. 

**Low-quality bins** might be the result of:  

* Problems during reverse transcription, PCR amplification or library preparation  
* Cell damage during the experiment, e.g. when the tissue already contains a lot of dead or dying cells  
* Very few transcripts overall, e.g. in empty regions  
* Unusually high numbers of transcripts, possibly doublets or noise  

**Why does this matter?**  
Low-quality bins can distort the results. For instance, they might cluster separately and be falsely interpreted as novel biological states or cell types. Performing QC early helps ensure the reliability of downstream steps like normalization, clustering, and cell type annotation.

## QC metrics at a glance

We will use three common metrics to flag low-quality bins:

- **Number of counts (UMIs):** Measures total expression in a bin.  low = empty; too high = potential artifacts.
- **Number of detected genes:** Captures the diversity of expression in a bin. low = poor capture, high = overlap (mix of tissue)
- **Mitochondrial gene content:** High levels often indicate stressed or dying cells. Important note: high mitochondrial levels  can also be characteristic of tissue: e.g. intestinal epithelium is characterized by high mitochondrial activity (e.g.absorption)

These metrics will be assessed both statistically and spatially to get an idea of the sample quality and to identify thresholds for filtering.

## Number of Counts per Bin

The total number of UMIs (counts) per bin gives a sense of overall transcript abundance.

```{r pressure, echo=FALSE}
p1 = VlnPlot(sp, features="nCount_RNA", pt.size=0, layer="counts") + NoLegend()
p2 = SpatialFeaturePlot(sp, features="nCount_RNA")
p1 | p2

summary(sp$nCount_RNA)
```

Look for bins with very few or very many counts. Bins with <30 counts or >2000 counts are suspicious and flagged for removal. 

### Bins flagged here should appear randomly across the tissue #####
If they form a distinct pattern, reconsider the threshold — you might be removing biologically relevant data.

```{r}
#| label: qc_2

filtered_bins_counts = WhichCells(sp, expression=nCount_RNA < 30 | nCount_RNA > 2000)
SpatialDimPlot(sp, cells.highlight=filtered_bins_counts, cols.highlight=c("#FFFF00", "grey50")) + NoLegend() + ggtitle(paste(length(filtered_bins_counts), "bins filtered"))
```

### Find your optimal threshold
Play around with the thresholds in R. Which threshold would you find best?

## Number of Genes per Bin

This tells us how many genes are detected per bin — essentially a measure of complexity.

```{r}
#| label: qc_3

p1 = VlnPlot(sp, features="nFeature_RNA", pt.size=0, layer="counts") + NoLegend()
p2 = SpatialFeaturePlot(sp, features="nFeature_RNA")
p1 | p2

summary(sp$nFeature_RNA)
```

```{r}
#| label: qc_4

filtered_bins_genes = WhichCells(sp, expression = nFeature_RNA < 30 | nFeature_RNA > 1000)
SpatialDimPlot(sp, cells.highlight=filtered_bins_genes, cols.highlight=c("#FFFF00", "grey50")) + NoLegend() + ggtitle(paste(length(filtered_bins_genes), "bins filtered"))
```

## Mitochondrial content

Mitochondrial RNA (mtRNA) often increases when cells are stressed or dying. A high percentage is a red flag.

We identify mitochondrial genes using a prefix ("^mt-" means all genes starting with "mt-", for human 'MT') and calculate their percentage per bin:

```{r}
#| label: qc_5

sp = PercentageFeatureSet(sp, pattern="^mt-", col.name="pMito_RNA") 

p1 = VlnPlot(sp, features="pMito_RNA", pt.size=0, layer="counts") + NoLegend()
p2 = SpatialFeaturePlot(sp, features="pMito_RNA") 
p1 | p2
```

```{r}
#| label: qc_6

filtered_bins_mito = WhichCells(sp, expression=pMito_RNA>10)
SpatialDimPlot(sp, cells.highlight=filtered_bins_mito, cols.highlight=c("#FFFF00", "grey50")) + NoLegend() + ggtitle(paste(length(filtered_bins_mito), "bins filtered"))
```

## Assignment

Calculate another QC metric that shows the percentage of counts from hemoglobin genes per bin. You can identify hemoglobin genes by the prefix '^Hb[ab]-'.

Next, visualize this metric using both a violin plot and a spatial plot. Do many bins show a high proportion of hemoglobin expression?


## Filtering of bins

Once you have reviewed the metrics and decided on thresholds, remove poor-quality bins using subset():

Before filtering:

```{r}
#| label: qc_7

dim(sp[["RNA"]])
```

Apply the filters:

```{r}
#| label: qc_8

sp = subset(sp, nCount_RNA < 30 | nCount_RNA > 2000, invert=TRUE) %>% suppressWarnings()
sp = subset(sp, nFeature_RNA < 30 | nFeature_RNA > 1000, invert=TRUE) %>% suppressWarnings()
sp = subset(sp, pMito_RNA > 30, invert=TRUE) %>% suppressWarnings()
dim(sp[["RNA"]])
```

## Filtering of genes

Genes expressed in only a few bins can add noise. First, we count how many bins each gene is detected in:

```{r}
#| label: qc_9

counts = GetAssayData(sp, layer="counts")
genes_expressed = rowSums(counts > 0)
head(genes_expressed, 5)
```

Let us quickly summarize these numbers. Most of the genes are expressed in at least 68 bins, on average in 5529 bins and maximum in 222930 bins.

```{r}
#| label: qc_10

summary(genes_expressed)
```

Keep genes expressed in >10 bins:

```{r}
#| label: qc_11

genes_expressed = genes_expressed[genes_expressed > 10]
length(genes_expressed)

```

Then subset the Seurat object:

```{r}
#| label: qc_12

sp[["RNA"]]
sp[["RNA"]] = subset(sp[["RNA"]], features=names(genes_expressed)) %>% suppressWarnings()
sp[["RNA"]]

gc()

```

### Best practices
* Avoid "one-size-fits-all" thresholds; adjust based on sample type, bin size, and sequencing depth
* Make sure to check the spatial distribution of filtered bins to avoid removing spatial patterns
* At the beginning, run a full analysis (until clustering) without filtering 
  * Low-quality bins often cluster together
  * Plot QC metrics per cluster and identify clusters without or with ambiguous cell type
  * Then adjust filtering criteria accordingly and repeat
* Advanced: use tools that include neighboring bins (e.g [SpotSweeper](https://github.com/MicTott/SpotSweeper))


### Questions  
What might cause unusually high count bins?  
Why might mitochondrial content be misleading in some tissues (e.g., muscle or brain)?  
What are the trade-offs of stricter vs. more lenient filtering?  
:::

## 3. Processing pipeline

After removing low-quality bins, we now prepare the dataset for downstream analysis. This **processing pipeline** includes:

1. Normalization of raw counts
2. Identification of highly variable genes (HVGs)
3. Centering and scaling of those HVGs
(4. Optional sketching of the dataset for speed (HVGs))
5. Dimensionality reduction (PCA) based on the HVGs

Each step ensures that only informative, reliable data is passed into clustering and annotation workflows.

## Normalization

Raw counts vary widely across bins due to differences in sequencing depth (library size). To make counts **comparable across bins**, we perform normalization.

For this workshop, we apply log-normalization. 

**How does it work?**  

* Per bin, the count for each gene is divided by the total count for that bin, and then multiplied by 10,000  
* These "counts per 10,000" are then log-transformed using the natural logarithm  

This is implemented in Seurat with `NormalizeData()`:

```{r}
#| label: processing_1

sp = NormalizeData(sp, normalization.method="LogNormalize", scale.factor=10000)
sp[["RNA"]]
```

**NOTE!!!**  If you find problems running this function on your computer please run preprocessing_7 before the Normalization. Then you do not have to run it below

This creates a new layer in the assay object called `data` that contains the normalized counts. You can inspect the normalized values like so:

```{r}
#| label: processing_2

data = GetAssayData(sp, layer="data")
data[1:10, 1:10]
```

## Identifying Highly Variable Genes (HVGs)

Not all genes are equally informative. Experience shows that 1,000-3,000 genes with the highest bin-to-bin variation are often sufficient to describe the global structure of a dataset. 

Highly variable genes are typically the genes that show strong variation across bins and are more likely to distinguish biological states. Housekeeping genes with similar expression profiles across all bins, or genes with minor expression differences, might add random noise and mask relevant changes during downstream analysis. 

Here, we determine the top 1000 HVGs: 

```{r}
#| label: processing_3

sp = FindVariableFeatures(sp, nfeatures=1000)
```

Note that 1,000 HVGs represents the lower end of the possible range. However, for demonstration purposes and to save memory, we use 1,000 in this example.

Get the top 10 HVGs and plot them:

```{r}
#| label: processing_4

top10 = VariableFeatures(sp) %>% head(10)
top10

p = VariableFeaturePlot(sp, selection.method="vst")
p = LabelPoints(plot=p, points=top10, repel=TRUE)
p
```

## Data scaling

Gene expression ranges vary; some genes have inherently higher values. Centering and scaling ensures each gene contributes equally during the analysis. By centering (mean expression of 0) and scaling (standard deviation of 1), all genes will be on the same scale which makes them comparable. 

We use the `ScaleData` function to center and scale the HVGs:

```{r}
#| label: processing_5

sp = ScaleData(sp, features=VariableFeatures(sp))
GetAssay(sp, assay="RNA")
```

This creates a new layer in the assay object called `scale.data` that contains the scaled counts:

```{r}
#| label: preprocessing_6

scale_data = GetAssayData(sp, layer="scale.data")
scale_data[1:5, 1:5]
```

## Creating a sketch assay

Large datasets can slow down clustering and UMAP. A sketch assay creates a reduced representation while preserving rare cell populations.

Instead of random sampling, Seurat uses a leverage score to keep influential or rare bins. We sketch 50,000 bins:

```{r}
#| label: preprocessing_7

sp = SketchData(sp, ncells=50000, method="LeverageScore", sketched.assay="sketch", features=VariableFeatures(sp))
sp
```

When we print the Seurat object, we see that the default assay is now the sketch assay. We can also check that it is indeed smaller:

```{r}
#| label: preprocessing_8

GetAssay(sp, assay="sketch")
```

Repeat HVG selection and scaling for the sketch assay:

```{r}
#| label: preprocessing_9

sp = FindVariableFeatures(sp, nfeatures=1000)
sp = ScaleData(sp, features=VariableFeatures(sp))
GetAssay(sp, assay="sketch")
```

### Tip
Sketching is ideal for exploration on (very) large datasets. If your computing machine is super powerful or your dataset reasonably small, you might not need it. 

## Dimensionality reduction

With ~20,000 genes, the data is too high-dimensional for visualization or clustering. At this point of the analysis, we have already reduced the dimensionality of the dataset to 1,000 HVGs. The biological manifold however can be described by far fewer dimensions than the number of (variable) genes, since expression profiles of different genes are correlated if they are involved in the same biological process. 

We use Principal Component Analysis (PCA) to reduce the dimensionality. PCA finds new axes (PCs) that capture the most variance in the dataset, and projects the data onto these axes. The resulting meta-variables are called principal components (PCs).

We use the `RunPCA` function to calculate the top 80 principle components (PCs) for the data. This creates a new dimensionality reduction object called `pca.sketch`:

```{r}
#| label: preprocessing_10

sp = RunPCA(sp, reduction.name="pca.sketch", features=VariableFeatures(sp), npcs=80, nfeatures.print=5)
Reductions(sp, slot="pca.sketch")
```

Visualize first two PCs:

```{r}
#| label: preprocessing_11

DimPlot(sp, reduction="pca.sketch", dims=c(1, 2))
```

## Assignment
Visualize the PCA for PC2 and PC3. 

In PCA, genes with the largest variation between bins will have the biggest influence on the PCs. The first PC captures the greatest variance across the dataset. The next PC captures the greatest remaining amount of variance, and so on. This way, the top PCs are likely to represent the biological signal where multiple genes are affected by the same biological processes in a coordinated way. In contrast, random technical or biological noise that affects each gene independently are contained in later PCs. 

Downstream analysis can be restricted to the top PCs. We need to decide how many PCs we want to use for our analysis. The following elbow plot shows PCs ranked based on the variance they explain. 

Look for the "elbow" — a point where adding more PCs gives diminishing returns:

```{r}
#| label: preprocessing_12

ElbowPlot(sp, reduction="pca.sketch", ndims=80)
```

You can also check which genes contribute most to each PC:

```{r}
#| label: preprocessing_13

VizDimLoadings(sp, reduction="pca.sketch", dims=1:4, nfeatures=10, balanced=TRUE)
```

## Learnings
Helpful YouTube video on PCA in the context of gene expression analysis is [here](https://www.youtube.com/watch?v=FgakZw6K1QQ)

### Question
How many PCs would you choose for further analysis? 

# 4. Clustering and visualization

In the following, we **cluster** spatial bins based on their gene expression profiles and use **UMAP** (Uniform Manifold Approximation and Projection) to visualize the results in two dimensions.

**Clustering** is typically done using unsupervised algorithms (e.g., Louvain or Leiden) that group bins based on similarities across the full gene expression space. This helps to identify regions within the tissue that share similar transcriptional signatures, which may correspond to distinct anatomical structures or functional states. 

**UMAP** is a dimensionality reduction technique that projects high-dimensional data into a lower-dimensional space, in this case 2D, to reveal underlying structure. In UMAP plots, each bin is shown as a point, allowing us to detect substructures or transitions within clusters, identify outliers or ambiguous regions, communicate findings visually and intuitively. 

Clusters are discrete groupings assigned algorithmically based on expression similarity; each bin belongs to exactly one cluster. UMAP clouds, in contrast, are continuous visual projections. While clusters often appear as distinct clouds in UMAP space, overlaps can occur, especially in biologically complex areas. UMAP may reveal gradual transitions or relationships that clustering alone cannot capture.

## Clustering of the sketched dataset

Seurat uses a graph-based approach for clustering. In short, Seurat first constructs a graph by identifying the k-nearest neighbors for each bin in the PCA space based on Euclidean distance (NN). It then builds a refined version of the neighbor graph by considering shared neighbors between bins (SNN). Finally, a clustering algorithm is applied to the graph to identify groups of similar bins. These groups are then considered distinct cell populations. 

We begin by creating a nearest-neighbor graph using the `FindNeighbors` function in Seurat. We use the first 40 PCs as input and set the number of nearest neighbors to 20:

```{r}
#| label: clustering_1

sp = FindNeighbors(sp, reduction="pca.sketch", dims=1:40, k.param=20)
Graphs(sp)
```

After constructing the nearest-neighbor graph, we apply the Leiden algorithm to perform the clustering. The Leiden algorithm is an improvement over the Louvain method and works by optimizing modularity. It groups bins into clusters such that bins within the same cluster are more connected to each other than to bins in other clusters.

We call the `FindClusters` function with `algorithm="leiden"`, which tells Seurat to use the Leiden algorithm. We also need to specify the resolution parameter. This parameter controls the granularity of the clustering:

* Higher resolution values lead to more clusters  
* Lower resolution values lead to fewer clusters  

We will start with a resolution of 0.8, but this can be adjusted later depending on the number of clusters you wish to identify:

```{r}
#| label: clustering_2

# method="igraph" is nessessary for Seurat versions < 5.2
sp <- FindClusters(sp, resolution = 0.8, algorithm = 4, random.seed = 42)
# Save as extra metadata column
sp$seurat_clusters.sketch = sp$seurat_clusters
```

The clusters are saved as bin metadata column `seurat_clusters.sketch`. Let us summarize the clustering of the sketched dataset:

```{r}
#| label: clustering_3

table(sp$seurat_clusters.sketch)
```

Note that we can provide multiple resolution values to test different clustering resolutions.

## Assignment
Test different cluster resolutions and observe the number of clusters you receive. 

## UMAP of the sketched dataset

Now, we move on to generating a UMAP plot, which provides a visual representation of the dataset in lower-dimensional space. This helps to visually identify groups of similar cells, making it easier to explore and interpret the data.

We run the `RunUMAP` function and use the first 30 PCs as input. This creates a new dimensionality reduction object called `umap.sketch`:

```{r}
#| label: clustering_4

# return.model is only needed when doing sketching
sp = RunUMAP(sp, reduction="pca.sketch", reduction.name="umap.sketch", dims=1:40, return.model=TRUE)
```

Note that `umap.sketch` is now the default dimensionality reduction. We can color the clustering on the UMAP as well as in spatial context:

```{r}
#| label: clustering_5
#| dpi: 75

p1 = DimPlot(sp, reduction="umap.sketch", label=TRUE) + NoLegend()
p2 = SpatialDimPlot(sp, images="slice1") + NoLegend() + scale_fill_manual(values=cal_pal50)
p1 | p2
```

Here we can clearly see that we only analysed a subsampled dataset.

## Assignment
Test different `n.neighbors` to find a good 2D representation of the dataset. Plot the old and new UMAP next to each other for comparison.

```{r}
#| label: clustering_4_5_test
sp = RunUMAP(sp, reduction="pca.sketch", reduction.name="umap.sketch.test", dims=1:40, 
             n.neighbors=100)

p1 = DimPlot(sp, reduction="umap.sketch", label=TRUE) + NoLegend()
p2 = DimPlot(sp, reduction="umap.sketch.test", label=TRUE) + NoLegend()
p1 | p2
```




## Recommendations

* Clustering  
  * Test different resolution values to find the best clustering solution for your data  
* UMAP  
  * UMAP "cloud" sizes and the distance between them may not be meaningful since the method has a local notion of distance
  * Helpful explanation on YouTube [here](https://www.youtube.com/watch?v=eN0wFzBA4Sc)
  * Helpful documentation and option to explore [here](https://pair-code.github.io/understanding-umap/)  
* Keep in mind that this represents only a portion of the entire dataset, and the full dataset may reveal additional insights
* Take your time. In scRNA-seq analysis, this is perhaps the most time-consuming step of the basic analysis

## Question   
* How many clusters do we have?    
* What can we already say about the clusters we have now?   

# 5. Cluster annotation

What cell types correspond to the clusters? To identify the cell types corresponding to the clusters, we typically follow these steps:

* **Cluster marker genes**: Use differential gene expression analysis to find genes that are specifically expressed in each cluster. These can serve as markers for the corresponding cell types.
* **Known marker genes**: Visualize the expression of known cell-type markers on the UMAP to help associate clusters with specific cell types.
* **Mapping a reference dataset**: Use external datasets to map cell-type labels onto your data, enhancing the accuracy of your cell-type predictions.

By using these strategies, you can correlate the clusters with biological cell types and better understand the cell composition of your dataset.

##  Cluster marker genes

One of the first steps in identifying the cell types of each cluster is to determine cluster-specific marker genes. These are genes that are significantly up- or down-regulated in one cluster compared to all other clusters, and they can be used to characterize the biological identity of the cells in each cluster. 

A good clustering of cells typically results in good marker genes. Hence, if you cannot find good marker genes you may need to go back to the start of the workflow and adapt your parameters. 

Resulting *p*-values are adjusted using the Bonferroni method. However, beware that *p*-values are likely inflated, since both clusters and marker genes were determined based on the same gene expression data, and there ought to be gene expression differences by design. Nevertheless, *p*-values can be used to sort and prioritize marker genes. 

You can use Seurat `FindMarkers` function to identify differentially expressed genes between clusters:

```{r}
#| label: clusterannot_1

markers = FindAllMarkers(object=sp,
                         test.use="wilcox",
                         layer="data",
                         only.pos=FALSE,
                         max.cells.per.ident=1000)
```

Let us now extract and visualize the top 3 marker genes for each cluster based on the adjusted p-value and log2 foldchange: 

```{r}
#| label: clusterannot_2

# Solution
markers_top = markers %>% 
  dplyr::group_by(cluster) %>% 
  dplyr::arrange(p_val_adj, avg_log2FC) %>% 
  dplyr::slice_head(n=3) %>% 
  dplyr::ungroup() %>% 
  as.data.frame()

gt::gt(markers_top) %>% 
  gt::tab_options(container.height=450)
```


Good marker genes are highly and possibly even only expressed in one cluster as compared to all other clusters. However, sometimes marker genes are also expressed in other clusters, or are declared as marker genes in these clusters, for example cell lineage markers that are shared by different cell sub types. To evaluate marker genes, it is essential to visualize their expression patterns.

```{r}
#| label: clusterannot_3
#| fig-height: 8
#| fig-width: 12

DotPlot(sp, features=markers_top$gene %>% unique()) +
  viridis::scale_color_viridis() + 
  ylab("Cluster") + xlab("") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=.5),
        legend.position="bottom") + 
  guides(size=guide_legend(order=1, title="Pct expressed"), color=guide_colorbar(title="Scaled Expression")) + 
  ggtitle("Top markers per cluster (expression scaled)")

DotPlot(sp, features=markers_top$gene %>% unique(), scale=FALSE) + 
  viridis::scale_color_viridis() + 
  ylab("Cluster") + xlab("") + 
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=.5),
        legend.position="bottom") + 
  guides(size=guide_legend(order=1, title="Pct expressed"), color=guide_colorbar(title="Average Expression")) +
  ggtitle("Top markers per cluster (expression unscaled)")

```

## Assignment
Take a good look at the dot plot. Which clusters do / do not have good marker genes? 

## Functional enrichment analysis

We can use the identified cluster marker genes to perform functional enrichment analysis. This helps us infer the potential biological identity or function of each cluster. For simplicity, we will use the online tool [Enrichr](https://maayanlab.cloud/Enrichr/) to perform this analysis. 

## Assignment

Try to find the identity of one cluster! 

## Plotting known marker genes

To further explore the results and visualize gene expression for known marker genes across different clusters, we can use various plotting functions.

A **violin plot** allows us to visualize the distribution of gene expression across clusters. For example, we can plot the expression of genes Acta2 and Apoe:

```{r}
#| label: plotting_1

VlnPlot(sp, features=c("Acta2", "Lyz1"), pt.size=0, ncol=1) + NoLegend()
```

We can also visualize the gene expression directly on top of the **UMAP plot**. This will show the expression of genes such as Acta2 and Apoe across all cells in the low-dimensional UMAP space:

```{r}
#| label: plotting_2

FeaturePlot(sp, features=c("Acta2", "Lyz1"))
```

Since we are working with spatial data, you can visualize gene expression in the **spatial context**, showing where the genes are expressed on the tissue section:

```{r}
#| label: plotting_3

SpatialFeaturePlot(sp, features=c("Acta2", "Lyz1"))
```

## In-house markers based annotation. We used a mixed of signature features per cluster as well as known gene markers for intestinal epithelium. In-house markers can be informed by flow-cytometry, immuno-histochemistry, qPCR etc. In-house gene list should be validated by external literature whenever possible.

For cell markers characteristic of human immune and mouse embryos please refer to https://www.celltypist.org
For additional markers one can always check https://www.proteinatlas.org

In this example you have my curated list for intestinal epithelium. Note that SI and colon have slight different cell compositions: e.g. No Paneth cells in colon.
```{r}
#| label: plotting_4

Marker_genes<-c('Ighm',"Cd74","Acta2","Stmn1",'Jchain',"Lyz1",'Reg3b',"Fabp2","Olfm4",'Uchl1' , "Muc3",  'Mki67',"Dclk1","Chgb",'Lyve1','Madcam1','Apoa4','Mcpt1','Tpm1')


DotPlot(sp, features=Marker_genes %>% unique()) +
  viridis::scale_color_viridis() + 
  ylab("Cluster") + xlab("") +
  theme(axis.text.x=element_text(angle=90, hjust=1, vjust=.5),
        legend.position="bottom") + 
  guides(size=guide_legend(order=1, title="Pct expressed"), color=guide_colorbar(title="Scaled Expression")) + 
  ggtitle("In-house markers per cluster (expression scaled)")
```

For a more detailed look, we can create a **heatmap** to visualize the expression of the same genes in a subset of bins (10000). This allows for a more focused analysis of gene expression patterns across specific clusters.

```{r}
#| label: plotting_5

set.seed(42)
cluster_bins = Cells(sp) %>% 
  sample(10000)


DoHeatmap(sp, features=Marker_genes, 
          cells=cluster_bins,
          group.colors=cal_pal50, 
          label=FALSE) + 
  scale_fill_viridis() +
  guides(colour="none")
```


# Cell type annotation by deconvolution

Spatial transcriptomics data often require deconvolution to **resolve the cellular composition** of individual spatial units (bins). This section guides you through the process of estimating cell type compositions in Visium HD data using the RCTD method from the `spacexr` package.

## What is deconvolution?

In spatial transcriptomics, such as 10x Visium HD, each bin may contain zero, one, or multiple cells, depending on the resolution, cell size, and local cell density. As a result, we cannot assume that each bin corresponds to a single cell. To address this, deconvolution methods are used to estimate the proportion of different cell types within each bin.

These methods also often incorporate spatial information (i.e., neighborhood relationships between bins) to improve accuracy.

One such method is **Robust Cell Type Decomposition (RCTD)**, implemented in the [`spacexr`](https://github.com/dmcable/spacexr) package. RCTD learns gene expression profiles of cell types from a **single-cell reference dataset** and uses these profiles to deconvolve spatial bins into estimated cell type compositions.

For this tutorial, we use a preprocessed reference derived from the [Tabula Muris senis](https://tabula-muris-senis.sf.czbiohub.org) single-cell dataset of large intestine.

We now prepare the `SpatialRNA` object required by `spacexr`:

```{r}
#| label: annot_1

# Counts
counts = GetAssayData(sp, assay="sketch", layer="counts")

# Coordinates
bins_sketch = Cells(sp[["sketch"]])
coords = GetTissueCoordinates(sp)[bins_sketch, 1:2]

# Total counts
total_counts = colSums(counts)

# Create spacexr SpatialRNA object
query = spacexr::SpatialRNA(coords, counts, total_counts)
```

## Load and prepare the reference dataset

We begin by loading the [Tabula Muris Senis large intestine dataset], which has been saved as a Seurat object:

```{r}
#| label: annot_2

load("datasets/TM_Intestine_facs_Figure.rda")
TM_Int<-UpdateSeuratObject(TM_Int)
TM_Int
```

We use the `Celltype` column for cell type annotations:

```{r}
#| label: annot_3

TM_Int[[]] %>% dplyr::select(Celltype) %>% head(10)
table(TM_Int$Celltype)
```

We convert this Seurat object into a `spacexr` Reference object:

```{r}
#| label: annot_4

# Counts
counts = GetAssayData(TM_Int, assay="RNA", layer="counts")

# Cell type labels
cell_types = as.factor(TM_Int$Celltype)
levels(cell_types) = gsub("/", "-", levels(cell_types))
cell_types = droplevels(cell_types)

# Total counts
total_counts = TM_Int$nReads

# Create Reference object
ref = spacexr::Reference(counts, cell_types, total_counts, n_max_cells=500)

gc()
```

## Run RCTD

We are now ready to run RCTD. However, since this step is time-consuming, we provide the results precomputed and saved in the file `datasets/RCTD.Rds`. For completeness, here is how you would normally run the algorithm:

```{r}
#| label: annot_5

# This will take five hours
#
RCTD = create.RCTD(query, ref, max_cores=12)
RCTD = run.RCTD(RCTD, doublet_mode = "doublet")
saveRDS(RCTD, "datasets/RCTD.Rds")
gc()
```

We simply load the results:

```{r}
#| label: annot_6

RCTD = readRDS("datasets/RCTD.Rds")
RCTD_results = RCTD@results$results_df
head(RCTD_results)
```

The `results_df` contains the main output of the deconvolution. Key columns include:  
* `spot_class`: classification of each bin ("singlet", "doublet_certain", "doublet_uncertain", "reject")  
* `first_type`: predicted identity of the first cell type  
* `second_type`: only populated for doublets

We now add these predictions to the bin metadata of the sp object:

```{r}
#| label: annot_7

# Add to sp object
RCTD_results = RCTD_results[, c("spot_class", "first_type", "second_type")]
colnames(RCTD_results) = c("doublet", "first_cell_type", "second_cell_type")
sp = AddMetaData(sp, metadata=RCTD_results)

# Replace NA (not available) with "unknown"
sp$doublet = as.character(sp$doublet)
sp$doublet[is.na(sp$doublet)] = "unknown"
sp$doublet = factor(sp$doublet)

sp$first_cell_type = as.character(sp$first_cell_type)
sp$first_cell_type[is.na(sp$first_cell_type)] = "Unknown"
sp$first_cell_type = factor(sp$first_cell_type)

sp$second_cell_type = as.character(sp$second_cell_type)
sp$second_cell_type[is.na(sp$second_cell_type)] = "Unknown"
sp$second_cell_type = factor(sp$second_cell_type)
```



## Visualize the results

We can now visualize cell type predictions. For example, here we highlight two predicted secretory cells (typically labeled as Enteroendocrine, and Tuft cells) on the spatial plot:
:
```{r}
#| label: annot_8

Idents(sp) = "first_cell_type"

secreted_cells = c("Paneth cells", "Enterocytes")
secreted_cells_bins = CellsByIdentities(sp, idents=secreted_cells)
secreted_cells_bins[["NA"]] = NULL

SpatialDimPlot(sp, cells.highlight=secreted_cells_bins, facet.highlight=TRUE, cols.highlight=c("#FFFF00", "grey50")) + NoLegend()
```
## Plot the reference-based cell annotations.
```{r}
#| label: plot_final
#| fig-height: 5
#| fig-width: 12

p1 = DimPlot(sp, reduction="umap.sketch", label=TRUE, group.by = 'first_cell_type') + NoLegend()+ scale_fill_manual(values=cal_pal50)
p2 = SpatialDimPlot(sp, group.by = 'first_cell_type') + scale_fill_manual(values=cal_pal50)
p1 | p2

```
## Annotate clusters and domains

Using the in house cell types, we can now try to annotate our clusters and domains. 

We plot the distribution of predicted cell types for the `seurat_clusters`:

```{r}
#| label: annot_10

# Call clusters and substitute cell types
Idents(sp)<-sp$seurat_clusters
new.cluster.ids <- c( "1", #1
                      "2", #2
                      "3", #3
                      "4", #4
                      "5", #5
                      "6", #6
                      "7", #7
                      "8", #8
                      "9", #9
                      "10", #10
                      "11", #11
                      "12", #12
                      "13", #13
                      "14", #14
                      "15", #15
                      "16", #16
                      "17", #17
                      "18", #18
                      "19", #19
                      "20", #20
                      "21" #21
)
names(new.cluster.ids) <- levels(sp)
sp <- RenameIdents(sp, new.cluster.ids)
sp$Celltype<-Idents(sp)

```

## Plot the cell annotations. always take into account that cell-types are subjects to granularity. Take immune cells for example, they have markers of B cells and macrophages, which 
```{r}
#| label: plot_final
#| fig-height: 5
#| fig-width: 12

p1 = DimPlot(sp, reduction="umap.sketch", label=TRUE) + NoLegend()+ scale_fill_manual(values=cal_pal50)
p2 = SpatialDimPlot(sp) + scale_fill_manual(values=cal_pal50)
p1 | p2

```
## Analysing the full dataset if you have no memory problems so far!

Once we have finished analyzing the sketched dataset, we can project the learned cluster labels, PCA, and UMAP from the sketch assay onto the entire dataset. This allows us to transfer the insights gained from the subsampled dataset to the full dataset, which may have additional complexity.

We use the `ProjectData` function to carry out this projection. Here’s the code to project the data from the sketch assay to the full dataset:

```{r}
#| label: plot_final2

sp = ProjectData(sp,
                 sketched.assay="sketch", assay="RNA", 
                 sketched.reduction="pca.sketch", full.reduction="pca", 
                 umap.model="umap.sketch",
                 refdata=list(seurat_clusters="seurat_clusters.sketch", Celltype.full='Celltype'),
                 dims=1:30)

# Fix the category levels for bin metadata column Seurat_clusters.008um and update the bin identities
sp$seurat_clusters = factor(sp$seurat_clusters, levels=levels(sp$seurat_clusters.sketch))
Idents(sp) = "seurat_clusters"

# Rename UMAP from full.umap.sketch to umap
umap = sp[["full.umap.sketch"]]
Key(umap) = "umap"
sp[["umap"]] = umap
sp[["full.umap.sketch"]] = NULL

# Set default assay back to RNA.008um
DefaultAssay(sp) = "RNA"
gc()
```

The Seurat object now contains a full PCA (`pca`), a full UMAP (`umap`) and a full clustering (`seurat_clusters). We color the clusters of the full dataset on the UMAP as well as in spatial context:

```{r}
#| label: plot_final3

p1 = DimPlot(sp, reduction="umap", label=TRUE, group.by = 'Celltype.full') + NoLegend()+ scale_fill_manual(values=cal_pal50)
p2 = SpatialDimPlot(sp) + NoLegend() + scale_fill_manual(values=cal_pal50)
p1 | p2
```


```{r}
#| label: loupe_export

# Only for the 8 um bins
bins_to_export = Cells(sp[["RNA.008um"]])

# Bin metadata
metadata_to_export = sp[[]][bins_to_export, ] %>%
  dplyr::select(orig.ident, seurat_clusters.008um) %>%
  tibble::rownames_to_column("barcode")

write.csv(metadata_to_export, "datasets/exported_bin_metadata.csv", row.names=FALSE)

# UMAP
umap_to_export = Embeddings(sp[["umap.008um"]])[bins_to_export, ] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Barcode")
write.csv(umap_to_export, "datasets/exported_umap.csv", row.names=FALSE)
```

Information about importing results into Loupe can be found in the [Loupe tutorial](https://www.10xgenomics.com/support/software/loupe-browser/latest/tutorials/introduction/lb-sc-interface-and-navigation).






# Spatial clustering and domains

So far, we have explored the **fundamentals of analyzing spatial (and single-cell) transcriptomic data** using Seurat. The workflow introduced above serves is a good starting point.

However, a key limitation of this approach is that it treats each spatial bin independently, without considering its physical context within the tissue. Spatial analysis methods aim to address this by incorporating neighborhood information—enhancing biological interpretation and robustness. Several steps in our basic workflow can be extended to include this spatial context.


### If there is time: spatial information in clustering
## What is BANKSY?

[BANKSY](https://github.com/prabhakarlab/Banksy) is a computational method specifically designed for spatial transcriptomics analysis. By integrating information from neighboring bins, BANKSY can reduce noise in gene expression data, distinguish between different cell types based on spatial context, and identify spatial domains. 

BANKSY represents each cell or bin not only by its own transcriptomic profile but also by the average expression of its local neighborhood. This dual representation captures both intrinsic cellular identity and microenvironmental context. The degree to which neighborhood information is incorporated is controlled by the lambda parameter:  

* Lower values (e.g., **lambda = 0.2**) emphasize immediate neighbors — useful for **cell typing**  
* Higher values (e.g., **lambda = 0.8**) incorporate broader spatial context — useful for **domain detection**  

Although BANKSY is a standalone tool with its own framework, it can be integrated into Seurat workflows using the `RunBanksy` function from the `SeuratWrappers` package. This allows users to apply BANKSY directly to Seurat objects.

In summary, BANKSY leverages the principle that a cell’s identity is shaped not only by its own gene expression but also by its surrounding environment. By adjusting a single hyperparameter, it provides flexibility to shift focus from cellular identity to higher-order tissue organization.

## Improve clustering with BANKSY

BANKSY can serve as an alternative to the default clustering approach we used earlier. In this step, we apply BANKSY with a low lambda value (0.2) to focus on local neighborhood information, and set the number of neighbors (k_geom) to 15.

**Note:** This step can be time- and memory-intensive.
This code sets up your R session to run computations in parallel using 10 cores and allows large objects (up to 100 GB) to be shared between the main session and the parallel workers.
```{r}
library(future)
options(future.globals.maxSize = 100 * 1024^3)  # must come before plan()
plan("multisession", workers = 10)

```


```{r}
#| label: spatial_1

sp = RunBanksy(sp,
               assay="RNA", assay_name="BANKSY",
               features="variable",
               lambda=0.2, k_geom=15,
               verbose=TRUE)

# Set it as default
DefaultAssay(sp) = "BANKSY"

gc()
```

At this point, we have created a new assay `BANKSY`, containing the BANKSY-transformed data, and have set it as the default.

**⚠️ Important**: BANKSY fills the `scale.data` layer. Therefore do not call `ScaleData` on the BANKSY assay as this negates the effects of lambda. 

```{r}
#| label: spatial_2

sp
```

Next, we apply PCA, clustering, and UMAP using the BANKSY assay. We use the first 15 PCs and set a clustering resolution of 0.5, though these values can and should be adjusted depending on your dataset.

```{r}
#| label: spatial_3

sp = RunPCA(sp, reduction.name="banksy_pca", features=rownames(sp[["BANKSY"]]), npcs=40, nfeatures.print=5)
sp = FindNeighbors(sp, reduction="banksy_pca", dims=1:30)
sp = FindClusters(sp, resolution=0.5, algorithm="leiden", random.seed=42)
sp = RunUMAP(sp, reduction="banksy_pca", reduction.name="banksy_umap", dims=1:40, return.model=TRUE)

sp$banksy_clusters = sp$seurat_clusters
DefaultAssay(sp) = "RNA"
```

Here we compare the results of default **Seurat clustering versus BANKSY clustering**, first using UMAP plots:

```{r}
#| label: spatial_4

p1 = DimPlot(sp, reduction="umap", label=TRUE, group.by="seurat_clusters") + NoLegend() + ggtitle("Seurat clustering")
p2 = DimPlot(sp, reduction="banksy_umap", label=TRUE, group.by="banksy_clusters") + NoLegend() + ggtitle("BANKSY clustering")
p1 | p2
```

And as spatial plots:

```{r}
#| label: spatial_5

p1 = SpatialDimPlot(sp, group.by="seurat_clusters") + NoLegend() + ggtitle("Seurat") + scale_fill_manual(values=cal_pal50)
p2 = SpatialDimPlot(sp, group.by="banksy_clusters") + NoLegend() + ggtitle("BANKSY") + scale_fill_manual(values=cal_pal50)
p1 | p2
```

## Recommendations
BANKSY does not automatically produce better results. Always evaluate both clustering outputs in the context of your biological question and data quality.

## Identifying spatial domains with BANKSY

In addition to improving clustering, BANKSY can be tuned to detect larger-scale tissue structures, often referred to as spatial domains. By increasing the `lambda` parameter and the number of neighbors (`k_geom`), BANKSY incorporates more spatial context and captures broader patterns of gene expression across the tissue.

In the following example, we set `lambda=0.8` and `k_geom=50` to include more neighboring bins in the analysis.

**Note:** We first remove the BANKSY assay from the previous run to conserve memory. This step is optional but will save us some memory resources.

```{r}
#| label: spatial_6

DefaultAssay(sp) = "RNA"
sp = RunBanksy(sp,
               assay="RNA", assay_name="BANKSY",
               features="variable",
               lambda=0.8, k_geom=50,
               verbose=TRUE)

# Set it as default
DefaultAssay(sp) = "BANKSY"

gc()
```

As before, we perform PCA, clustering, and UMAP on the BANKSY assay. We use the first 10 PCs and a clustering resolution of 0.5, but these values should again be adjusted depending on your dataset:

```{r}
#| label: spatial_7

sp = RunPCA(sp, reduction.name="banksy_pca", features=rownames(sp[["BANKSY"]]), npcs=40, nfeatures.print=5)
sp = FindNeighbors(sp, reduction="banksy_pca", dims=1:40)
sp = FindClusters(sp, resolution=0.5, algorithm="leiden")
sp$banksy_domains.008um = sp$seurat_clusters
```

If your clustering results look similar to those from the previous BANKSY run (with `lambda=0.2`), this could indicate that the dominant tissue structures are already captured at a local level. We encourage you to systematically explore different parameter settings for `lambda`, `k_geom`, and `resolution` to assess their impact on clustering outcomes and spatial domain resolution.

Since this BANKSY run is also complete, we again remove the assay and PCA reduction to free up memory:

```{r}
#| label: spatial_8

# Remove BANKSY assay and pca since not used anymore and we need the memory.
DefaultAssay(sp) = "RNA"
sp[["BANKSY"]] = NULL
sp[["banksy_pca<"]] = NULL
gc()
```

## Recommended reading

If you want to learn more about BANKSY, we find these pages helpful: 

* https://github.com/satijalab/seurat-wrappers/blob/master/docs/banksy.md  
* https://github.com/prabhakarlab/Banksy?tab=readme-ov-file  


# Session info

To enhance reproducibility and facilitate the sharing of your analysis, it is good practice to include information about the R session and the packages used:

```{r}
#| label: session_info

sessioninfo::session_info()
```

# Useful resources

- Best practices:
  - [Single-cell best practices](https://www.sc-best-practices.org/preamble.html)
  - [Orchestrating Single-Cell Analysis with Bioconductor
](https://bioconductor.org/books/release/OSCA/)
  - [Orchestrating Spatial Transcriptomics Analysis with Bioconductor
](https://lmweber.org/OSTA/)
- Seurat:
  - [Essential commands](https://satijalab.org/seurat/articles/essential_commands)
  - [Basic Single-cell Analysis Vignette](https://satijalab.org/seurat/articles/pbmc3k_tutorial)
  - [Seurat Visium Analysis Vignette](https://satijalab.org/seurat/articles/spatial_vignette)
  - [Seurat Visium HD Analysis Vignette](https://satijalab.org/seurat/articles/visiumhd_analysis_vignette)
- Tools:
  - [Spaceranger](https://www.10xgenomics.com/support/software/space-ranger/latest)
  - [Loupe Browser](https://www.10xgenomics.com/support/software/loupe-browser/latest)
  - [Spotsweeper](https://github.com/MicTott/SpotSweeper)
  - [banksy](https://github.com/prabhakarlab/Banksy)




